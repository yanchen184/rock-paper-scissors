{"version":3,"file":"index.esm-Bh2yHDC9.js","sources":["../../node_modules/@firebase/installations/dist/esm/index.esm2017.js","../../node_modules/@firebase/analytics/dist/esm/index.esm2017.js"],"sourcesContent":["import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { openDB } from 'idb';\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.9\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PENDING_TIMEOUT_MS = 10000;\r\nconst PACKAGE_VERSION = `w:${version}`;\r\nconst INTERNAL_AUTH_VERSION = 'FIS_v2';\r\nconst INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\r\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\r\nconst SERVICE = 'installations';\r\nconst SERVICE_NAME = 'Installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERROR_DESCRIPTION_MAP = {\r\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: \"{$valueName}\"',\r\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */]: 'Firebase Installation is not registered.',\r\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',\r\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\r\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */]: 'Could not process request. Application offline.',\r\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */]: \"Can't delete installation while there is a pending registration request.\"\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\r\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\r\nfunction isServerError(error) {\r\n    return (error instanceof FirebaseError &&\r\n        error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getInstallationsEndpoint({ projectId }) {\r\n    return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\r\n}\r\nfunction extractAuthTokenInfoFromResponse(response) {\r\n    return {\r\n        token: response.token,\r\n        requestStatus: 2 /* RequestStatus.COMPLETED */,\r\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\r\n        creationTime: Date.now()\r\n    };\r\n}\r\nasync function getErrorFromResponse(requestName, response) {\r\n    const responseJson = await response.json();\r\n    const errorData = responseJson.error;\r\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */, {\r\n        requestName,\r\n        serverCode: errorData.code,\r\n        serverMessage: errorData.message,\r\n        serverStatus: errorData.status\r\n    });\r\n}\r\nfunction getHeaders({ apiKey }) {\r\n    return new Headers({\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\nfunction getHeadersWithAuth(appConfig, { refreshToken }) {\r\n    const headers = getHeaders(appConfig);\r\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\r\n    return headers;\r\n}\r\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */\r\nasync function retryIfServerError(fn) {\r\n    const result = await fn();\r\n    if (result.status >= 500 && result.status < 600) {\r\n        // Internal Server Error. Retry request.\r\n        return fn();\r\n    }\r\n    return result;\r\n}\r\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\r\n    // This works because the server will never respond with fractions of a second.\r\n    return Number(responseExpiresIn.replace('s', '000'));\r\n}\r\nfunction getAuthorizationHeader(refreshToken) {\r\n    return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {\r\n    const endpoint = getInstallationsEndpoint(appConfig);\r\n    const headers = getHeaders(appConfig);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        fid,\r\n        authVersion: INTERNAL_AUTH_VERSION,\r\n        appId: appConfig.appId,\r\n        sdkVersion: PACKAGE_VERSION\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const registeredInstallationEntry = {\r\n            fid: responseValue.fid || fid,\r\n            registrationStatus: 2 /* RequestStatus.COMPLETED */,\r\n            refreshToken: responseValue.refreshToken,\r\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\r\n        };\r\n        return registeredInstallationEntry;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Create Installation', response);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a promise that resolves after given time passes. */\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction bufferToBase64UrlSafe(array) {\r\n    const b64 = btoa(String.fromCharCode(...array));\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\r\nconst INVALID_FID = '';\r\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */\r\nfunction generateFid() {\r\n    try {\r\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\r\n        // bytes. our implementation generates a 17 byte array instead.\r\n        const fidByteArray = new Uint8Array(17);\r\n        const crypto = self.crypto || self.msCrypto;\r\n        crypto.getRandomValues(fidByteArray);\r\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\r\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\r\n        const fid = encode(fidByteArray);\r\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\r\n    }\r\n    catch (_a) {\r\n        // FID generation errored\r\n        return INVALID_FID;\r\n    }\r\n}\r\n/** Converts a FID Uint8Array to a base64 string representation. */\r\nfunction encode(fidByteArray) {\r\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\r\n    // Remove the 23rd character that was added because of the extra 4 bits at the\r\n    // end of our 17 byte array, and the '=' padding.\r\n    return b64String.substr(0, 22);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a string key that can be used to identify the app. */\r\nfunction getKey(appConfig) {\r\n    return `${appConfig.appName}!${appConfig.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst fidChangeCallbacks = new Map();\r\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */\r\nfunction fidChanged(appConfig, fid) {\r\n    const key = getKey(appConfig);\r\n    callFidChangeCallbacks(key, fid);\r\n    broadcastFidChange(key, fid);\r\n}\r\nfunction addCallback(appConfig, callback) {\r\n    // Open the broadcast channel if it's not already open,\r\n    // to be able to listen to change events from other tabs.\r\n    getBroadcastChannel();\r\n    const key = getKey(appConfig);\r\n    let callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        callbackSet = new Set();\r\n        fidChangeCallbacks.set(key, callbackSet);\r\n    }\r\n    callbackSet.add(callback);\r\n}\r\nfunction removeCallback(appConfig, callback) {\r\n    const key = getKey(appConfig);\r\n    const callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        return;\r\n    }\r\n    callbackSet.delete(callback);\r\n    if (callbackSet.size === 0) {\r\n        fidChangeCallbacks.delete(key);\r\n    }\r\n    // Close broadcast channel if there are no more callbacks.\r\n    closeBroadcastChannel();\r\n}\r\nfunction callFidChangeCallbacks(key, fid) {\r\n    const callbacks = fidChangeCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    for (const callback of callbacks) {\r\n        callback(fid);\r\n    }\r\n}\r\nfunction broadcastFidChange(key, fid) {\r\n    const channel = getBroadcastChannel();\r\n    if (channel) {\r\n        channel.postMessage({ key, fid });\r\n    }\r\n    closeBroadcastChannel();\r\n}\r\nlet broadcastChannel = null;\r\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\r\nfunction getBroadcastChannel() {\r\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\r\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\r\n        broadcastChannel.onmessage = e => {\r\n            callFidChangeCallbacks(e.data.key, e.data.fid);\r\n        };\r\n    }\r\n    return broadcastChannel;\r\n}\r\nfunction closeBroadcastChannel() {\r\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\r\n        broadcastChannel.close();\r\n        broadcastChannel = null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DATABASE_NAME = 'firebase-installations-database';\r\nconst DATABASE_VERSION = 1;\r\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(OBJECT_STORE_NAME);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\n/** Assigns or overwrites the record for the given key with the given value. */\r\nasync function set(appConfig, value) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await objectStore.get(key));\r\n    await objectStore.put(value, key);\r\n    await tx.done;\r\n    if (!oldValue || oldValue.fid !== value.fid) {\r\n        fidChanged(appConfig, value.fid);\r\n    }\r\n    return value;\r\n}\r\n/** Removes record(s) from the objectStore that match the given key. */\r\nasync function remove(appConfig) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\r\n    await tx.done;\r\n}\r\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */\r\nasync function update(appConfig, updateFn) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await store.get(key));\r\n    const newValue = updateFn(oldValue);\r\n    if (newValue === undefined) {\r\n        await store.delete(key);\r\n    }\r\n    else {\r\n        await store.put(newValue, key);\r\n    }\r\n    await tx.done;\r\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\r\n        fidChanged(appConfig, newValue.fid);\r\n    }\r\n    return newValue;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */\r\nasync function getInstallationEntry(installations) {\r\n    let registrationPromise;\r\n    const installationEntry = await update(installations.appConfig, oldEntry => {\r\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\r\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\r\n        registrationPromise = entryWithPromise.registrationPromise;\r\n        return entryWithPromise.installationEntry;\r\n    });\r\n    if (installationEntry.fid === INVALID_FID) {\r\n        // FID generation failed. Waiting for the FID from the server.\r\n        return { installationEntry: await registrationPromise };\r\n    }\r\n    return {\r\n        installationEntry,\r\n        registrationPromise\r\n    };\r\n}\r\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */\r\nfunction updateOrCreateInstallationEntry(oldEntry) {\r\n    const entry = oldEntry || {\r\n        fid: generateFid(),\r\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n    };\r\n    return clearTimedOutRequest(entry);\r\n}\r\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */\r\nfunction triggerRegistrationIfNecessary(installations, installationEntry) {\r\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        if (!navigator.onLine) {\r\n            // Registration required but app is offline.\r\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */));\r\n            return {\r\n                installationEntry,\r\n                registrationPromise: registrationPromiseWithError\r\n            };\r\n        }\r\n        // Try registering. Change status to IN_PROGRESS.\r\n        const inProgressEntry = {\r\n            fid: installationEntry.fid,\r\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n            registrationTime: Date.now()\r\n        };\r\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\r\n        return { installationEntry: inProgressEntry, registrationPromise };\r\n    }\r\n    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        return {\r\n            installationEntry,\r\n            registrationPromise: waitUntilFidRegistration(installations)\r\n        };\r\n    }\r\n    else {\r\n        return { installationEntry };\r\n    }\r\n}\r\n/** This will be executed only once for each new Firebase Installation. */\r\nasync function registerInstallation(installations, installationEntry) {\r\n    try {\r\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\r\n        return set(installations.appConfig, registeredInstallationEntry);\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) && e.customData.serverCode === 409) {\r\n            // Server returned a \"FID cannot be used\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            // Registration failed. Set FID as not registered.\r\n            await set(installations.appConfig, {\r\n                fid: installationEntry.fid,\r\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n            });\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n/** Call if FID registration is pending in another request. */\r\nasync function waitUntilFidRegistration(installations) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateInstallationRequest(installations.appConfig);\r\n    while (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // createInstallation request still in progress.\r\n        await sleep(100);\r\n        entry = await updateInstallationRequest(installations.appConfig);\r\n    }\r\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\r\n        if (registrationPromise) {\r\n            return registrationPromise;\r\n        }\r\n        else {\r\n            // if there is no registrationPromise, entry is registered.\r\n            return installationEntry;\r\n        }\r\n    }\r\n    return entry;\r\n}\r\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateInstallationRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!oldEntry) {\r\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */);\r\n        }\r\n        return clearTimedOutRequest(oldEntry);\r\n    });\r\n}\r\nfunction clearTimedOutRequest(entry) {\r\n    if (hasInstallationRequestTimedOut(entry)) {\r\n        return {\r\n            fid: entry.fid,\r\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n        };\r\n    }\r\n    return entry;\r\n}\r\nfunction hasInstallationRequestTimedOut(installationEntry) {\r\n    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {\r\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        installation: {\r\n            sdkVersion: PACKAGE_VERSION,\r\n            appId: appConfig.appId\r\n        }\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\r\n        return completedAuthToken;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Generate Auth Token', response);\r\n    }\r\n}\r\nfunction getGenerateAuthTokenEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */\r\nasync function refreshAuthToken(installations, forceRefresh = false) {\r\n    let tokenPromise;\r\n    const entry = await update(installations.appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\r\n            // There is a valid token in the DB.\r\n            return oldEntry;\r\n        }\r\n        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // There already is a token request in progress.\r\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\r\n            return oldEntry;\r\n        }\r\n        else {\r\n            // No token or token expired.\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\r\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\r\n            return inProgressEntry;\r\n        }\r\n    });\r\n    const authToken = tokenPromise\r\n        ? await tokenPromise\r\n        : entry.authToken;\r\n    return authToken;\r\n}\r\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */\r\nasync function waitUntilAuthTokenRequest(installations, forceRefresh) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateAuthTokenRequest(installations.appConfig);\r\n    while (entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // generateAuthToken still in progress.\r\n        await sleep(100);\r\n        entry = await updateAuthTokenRequest(installations.appConfig);\r\n    }\r\n    const authToken = entry.authToken;\r\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        return refreshAuthToken(installations, forceRefresh);\r\n    }\r\n    else {\r\n        return authToken;\r\n    }\r\n}\r\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateAuthTokenRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\r\n            return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n        }\r\n        return oldEntry;\r\n    });\r\n}\r\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\r\n    try {\r\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\r\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });\r\n        await set(installations.appConfig, updatedInstallationEntry);\r\n        return authToken;\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) &&\r\n            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\r\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n            await set(installations.appConfig, updatedInstallationEntry);\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nfunction isEntryRegistered(installationEntry) {\r\n    return (installationEntry !== undefined &&\r\n        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);\r\n}\r\nfunction isAuthTokenValid(authToken) {\r\n    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&\r\n        !isAuthTokenExpired(authToken));\r\n}\r\nfunction isAuthTokenExpired(authToken) {\r\n    const now = Date.now();\r\n    return (now < authToken.creationTime ||\r\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\r\n}\r\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\r\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\r\n    const inProgressAuthToken = {\r\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n        requestTime: Date.now()\r\n    };\r\n    return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });\r\n}\r\nfunction hasAuthTokenRequestTimedOut(authToken) {\r\n    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a Firebase Installation if there isn't one for the app and\r\n * returns the Installation ID.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function getId(installations) {\r\n    const installationsImpl = installations;\r\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\r\n    if (registrationPromise) {\r\n        registrationPromise.catch(console.error);\r\n    }\r\n    else {\r\n        // If the installation is already registered, update the authentication\r\n        // token if needed.\r\n        refreshAuthToken(installationsImpl).catch(console.error);\r\n    }\r\n    return installationEntry.fid;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a Firebase Installations auth token, identifying the current\r\n * Firebase Installation.\r\n * @param installations - The `Installations` instance.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nasync function getToken(installations, forceRefresh = false) {\r\n    const installationsImpl = installations;\r\n    await completeInstallationRegistration(installationsImpl);\r\n    // At this point we either have a Registered Installation in the DB, or we've\r\n    // already thrown an error.\r\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\r\n    return authToken.token;\r\n}\r\nasync function completeInstallationRegistration(installations) {\r\n    const { registrationPromise } = await getInstallationEntry(installations);\r\n    if (registrationPromise) {\r\n        // A createInstallation request is in progress. Wait until it finishes.\r\n        await registrationPromise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function deleteInstallationRequest(appConfig, installationEntry) {\r\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    const request = {\r\n        method: 'DELETE',\r\n        headers\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (!response.ok) {\r\n        throw await getErrorFromResponse('Delete Installation', response);\r\n    }\r\n}\r\nfunction getDeleteEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Deletes the Firebase Installation and all associated data.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function deleteInstallations(installations) {\r\n    const { appConfig } = installations;\r\n    const entry = await update(appConfig, oldEntry => {\r\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n            // Delete the unregistered entry without sending a deleteInstallation request.\r\n            return undefined;\r\n        }\r\n        return oldEntry;\r\n    });\r\n    if (entry) {\r\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // Can't delete while trying to register.\r\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */);\r\n        }\r\n        else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */) {\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            else {\r\n                await deleteInstallationRequest(appConfig, entry);\r\n                await remove(appConfig);\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n * @param installations - The `Installations` instance.\r\n * @param callback - The callback function that is invoked when FID changes.\r\n * @returns A function that can be called to unsubscribe.\r\n *\r\n * @public\r\n */\r\nfunction onIdChange(installations, callback) {\r\n    const { appConfig } = installations;\r\n    addCallback(appConfig, callback);\r\n    return () => {\r\n        removeCallback(appConfig, callback);\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an instance of {@link Installations} associated with the given\r\n * {@link @firebase/app#FirebaseApp} instance.\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * @public\r\n */\r\nfunction getInstallations(app = getApp()) {\r\n    const installationsImpl = _getProvider(app, 'installations').getImmediate();\r\n    return installationsImpl;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction extractAppConfig(app) {\r\n    if (!app || !app.options) {\r\n        throw getMissingValueError('App Configuration');\r\n    }\r\n    if (!app.name) {\r\n        throw getMissingValueError('App Name');\r\n    }\r\n    // Required app config keys\r\n    const configKeys = [\r\n        'projectId',\r\n        'apiKey',\r\n        'appId'\r\n    ];\r\n    for (const keyName of configKeys) {\r\n        if (!app.options[keyName]) {\r\n            throw getMissingValueError(keyName);\r\n        }\r\n    }\r\n    return {\r\n        appName: app.name,\r\n        projectId: app.options.projectId,\r\n        apiKey: app.options.apiKey,\r\n        appId: app.options.appId\r\n    };\r\n}\r\nfunction getMissingValueError(valueName) {\r\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, {\r\n        valueName\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INSTALLATIONS_NAME = 'installations';\r\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\r\nconst publicFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Throws if app isn't configured properly.\r\n    const appConfig = extractAppConfig(app);\r\n    const heartbeatServiceProvider = _getProvider(app, 'heartbeat');\r\n    const installationsImpl = {\r\n        app,\r\n        appConfig,\r\n        heartbeatServiceProvider,\r\n        _delete: () => Promise.resolve()\r\n    };\r\n    return installationsImpl;\r\n};\r\nconst internalFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Internal FIS instance relies on public FIS instance.\r\n    const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();\r\n    const installationsInternal = {\r\n        getId: () => getId(installations),\r\n        getToken: (forceRefresh) => getToken(installations, forceRefresh)\r\n    };\r\n    return installationsInternal;\r\n};\r\nfunction registerInstallations() {\r\n    _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n}\n\n/**\r\n * The Firebase Installations Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterInstallations();\r\nregisterVersion(name, version);\r\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\nregisterVersion(name, version, 'esm2017');\n\nexport { deleteInstallations, getId, getInstallations, getToken, onIdChange };\n//# sourceMappingURL=index.esm2017.js.map\n","import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Analytics.\r\n */\r\nconst ANALYTICS_TYPE = 'analytics';\r\n// Key to attach FID to in gtag params.\r\nconst GA_FID_KEY = 'firebase_id';\r\nconst ORIGIN_KEY = 'origin';\r\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\r\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\r\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/analytics');\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\r\n        ' already exists. ' +\r\n        'Only one Firebase Analytics instance can be created for each appId.',\r\n    [\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\r\n        'it was initially called with. It can be called again with the same options to ' +\r\n        'return the existing instance, or getAnalytics() can be used ' +\r\n        'to get a reference to the already-initialized instance.',\r\n    [\"already-initialized-settings\" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\r\n        'settings() must be called before initializing any Analytics instance' +\r\n        'or it will have no effect.',\r\n    [\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\r\n    [\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    [\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\r\n    [\"no-api-key\" /* AnalyticsError.NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid API key.',\r\n    [\"no-app-id\" /* AnalyticsError.NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid app ID.',\r\n    [\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */]: 'The \"client_id\" field is empty.',\r\n    [\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */]: 'Trusted Types detected an invalid gtag resource: {$gtagURL}.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Verifies and creates a TrustedScriptURL.\r\n */\r\nfunction createGtagTrustedTypesScriptURL(url) {\r\n    if (!url.startsWith(GTAG_URL)) {\r\n        const err = ERROR_FACTORY.create(\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */, {\r\n            gtagURL: url\r\n        });\r\n        logger.warn(err.message);\r\n        return '';\r\n    }\r\n    return url;\r\n}\r\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\r\nfunction promiseAllSettled(promises) {\r\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\r\n}\r\n/**\r\n * Creates a TrustedTypePolicy object that implements the rules passed as policyOptions.\r\n *\r\n * @param policyName A string containing the name of the policy\r\n * @param policyOptions Object containing implementations of instance methods for TrustedTypesPolicy, see {@link https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicy#instance_methods\r\n * | the TrustedTypePolicy reference documentation}.\r\n */\r\nfunction createTrustedTypesPolicy(policyName, policyOptions) {\r\n    // Create a TrustedTypes policy that we can use for updating src\r\n    // properties\r\n    let trustedTypesPolicy;\r\n    if (window.trustedTypes) {\r\n        trustedTypesPolicy = window.trustedTypes.createPolicy(policyName, policyOptions);\r\n    }\r\n    return trustedTypesPolicy;\r\n}\r\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction insertScriptTag(dataLayerName, measurementId) {\r\n    const trustedTypesPolicy = createTrustedTypesPolicy('firebase-js-sdk-policy', {\r\n        createScriptURL: createGtagTrustedTypesScriptURL\r\n    });\r\n    const script = document.createElement('script');\r\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\r\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\r\n    const gtagScriptURL = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\r\n    script.src = trustedTypesPolicy\r\n        ? trustedTypesPolicy === null || trustedTypesPolicy === void 0 ? void 0 : trustedTypesPolicy.createScriptURL(gtagScriptURL)\r\n        : gtagScriptURL;\r\n    script.async = true;\r\n    document.head.appendChild(script);\r\n}\r\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction getOrCreateDataLayer(dataLayerName) {\r\n    // Check for existing dataLayer and create if needed.\r\n    let dataLayer = [];\r\n    if (Array.isArray(window[dataLayerName])) {\r\n        dataLayer = window[dataLayerName];\r\n    }\r\n    else {\r\n        window[dataLayerName] = dataLayer;\r\n    }\r\n    return dataLayer;\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\r\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\r\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\r\n    /// are waiting for, and wait only on that one.\r\n    const correspondingAppId = measurementIdToAppId[measurementId];\r\n    try {\r\n        if (correspondingAppId) {\r\n            await initializationPromisesMap[correspondingAppId];\r\n        }\r\n        else {\r\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\r\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\r\n            // that appId's initialization promise. If there is none, promise resolves and gtag\r\n            // call goes through.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\r\n            if (foundConfig) {\r\n                await initializationPromisesMap[foundConfig.appId];\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, measurementId, gtagParams);\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\r\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\r\n    try {\r\n        let initializationPromisesToWaitFor = [];\r\n        // If there's a 'send_to' param, check if any ID specified matches\r\n        // an initializeIds() promise we are waiting for.\r\n        if (gtagParams && gtagParams['send_to']) {\r\n            let gaSendToList = gtagParams['send_to'];\r\n            // Make it an array if is isn't, so it can be dealt with the same way.\r\n            if (!Array.isArray(gaSendToList)) {\r\n                gaSendToList = [gaSendToList];\r\n            }\r\n            // Checking 'send_to' fields requires having all measurement ID results back from\r\n            // the dynamic config fetch.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            for (const sendToId of gaSendToList) {\r\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\r\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\r\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\r\n                if (initializationPromise) {\r\n                    initializationPromisesToWaitFor.push(initializationPromise);\r\n                }\r\n                else {\r\n                    // Found an item in 'send_to' that is not associated\r\n                    // directly with an FID, possibly a group.  Empty this array,\r\n                    // exit the loop early, and let it get populated below.\r\n                    initializationPromisesToWaitFor = [];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // This will be unpopulated if there was no 'send_to' field , or\r\n        // if not all entries in the 'send_to' field could be mapped to\r\n        // a FID. In these cases, wait on all pending initialization promises.\r\n        if (initializationPromisesToWaitFor.length === 0) {\r\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\r\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\r\n        }\r\n        // Run core gtag function with args after all relevant initialization\r\n        // promises have been resolved.\r\n        await Promise.all(initializationPromisesToWaitFor);\r\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\r\n        gtagCore(\"event\" /* GtagCommand.EVENT */, measurementId, gtagParams || {});\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n}\r\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\r\nfunction wrapGtag(gtagCore, \r\n/**\r\n * Allows wrapped gtag calls to wait on whichever initialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\r\ninitializationPromisesMap, \r\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\r\ndynamicConfigPromisesList, \r\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\r\nmeasurementIdToAppId) {\r\n    /**\r\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n     * @param command Gtag command type.\r\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n     * @param gtagParams Params if event is EVENT/CONFIG.\r\n     */\r\n    async function gtagWrapper(command, ...args) {\r\n        try {\r\n            // If event, check that relevant initialization promises have completed.\r\n            if (command === \"event\" /* GtagCommand.EVENT */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If EVENT, second arg must be measurementId.\r\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"config\" /* GtagCommand.CONFIG */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If CONFIG, second arg must be measurementId.\r\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"consent\" /* GtagCommand.CONSENT */) {\r\n                const [consentAction, gtagParams] = args;\r\n                // consentAction can be one of 'default' or 'update'.\r\n                gtagCore(\"consent\" /* GtagCommand.CONSENT */, consentAction, gtagParams);\r\n            }\r\n            else if (command === \"get\" /* GtagCommand.GET */) {\r\n                const [measurementId, fieldName, callback] = args;\r\n                gtagCore(\"get\" /* GtagCommand.GET */, measurementId, fieldName, callback);\r\n            }\r\n            else if (command === \"set\" /* GtagCommand.SET */) {\r\n                const [customParams] = args;\r\n                // If SET, second arg must be params.\r\n                gtagCore(\"set\" /* GtagCommand.SET */, customParams);\r\n            }\r\n            else {\r\n                gtagCore(command, ...args);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n    return gtagWrapper;\r\n}\r\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\r\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\r\n    // Create a basic core gtag function\r\n    let gtagCore = function (..._args) {\r\n        // Must push IArguments object, not an array.\r\n        window[dataLayerName].push(arguments);\r\n    };\r\n    // Replace it with existing one if found\r\n    if (window[gtagFunctionName] &&\r\n        typeof window[gtagFunctionName] === 'function') {\r\n        // @ts-ignore\r\n        gtagCore = window[gtagFunctionName];\r\n    }\r\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\r\n    return {\r\n        gtagCore,\r\n        wrappedGtag: window[gtagFunctionName]\r\n    };\r\n}\r\n/**\r\n * Returns the script tag in the DOM matching both the gtag url pattern\r\n * and the provided data layer name.\r\n */\r\nfunction findGtagScriptOnPage(dataLayerName) {\r\n    const scriptTags = window.document.getElementsByTagName('script');\r\n    for (const tag of Object.values(scriptTags)) {\r\n        if (tag.src &&\r\n            tag.src.includes(GTAG_URL) &&\r\n            tag.src.includes(dataLayerName)) {\r\n            return tag;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\r\nconst LONG_RETRY_FACTOR = 30;\r\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\r\nconst BASE_INTERVAL_MILLIS = 1000;\r\n/**\r\n * Stubbable retry data storage class.\r\n */\r\nclass RetryData {\r\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\r\n        this.throttleMetadata = throttleMetadata;\r\n        this.intervalMillis = intervalMillis;\r\n    }\r\n    getThrottleMetadata(appId) {\r\n        return this.throttleMetadata[appId];\r\n    }\r\n    setThrottleMetadata(appId, metadata) {\r\n        this.throttleMetadata[appId] = metadata;\r\n    }\r\n    deleteThrottleMetadata(appId) {\r\n        delete this.throttleMetadata[appId];\r\n    }\r\n}\r\nconst defaultRetryData = new RetryData();\r\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\r\nfunction getHeaders(apiKey) {\r\n    return new Headers({\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfig(appFields) {\r\n    var _a;\r\n    const { appId, apiKey } = appFields;\r\n    const request = {\r\n        method: 'GET',\r\n        headers: getHeaders(apiKey)\r\n    };\r\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\r\n    const response = await fetch(appUrl, request);\r\n    if (response.status !== 200 && response.status !== 304) {\r\n        let errorMessage = '';\r\n        try {\r\n            // Try to get any error message text from server response.\r\n            const jsonResponse = (await response.json());\r\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\r\n                errorMessage = jsonResponse.error.message;\r\n            }\r\n        }\r\n        catch (_ignored) { }\r\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */, {\r\n            httpStatus: response.status,\r\n            responseMessage: errorMessage\r\n        });\r\n    }\r\n    return response.json();\r\n}\r\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfigWithRetry(app, \r\n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\r\nretryData = defaultRetryData, timeoutMillis) {\r\n    const { appId, apiKey, measurementId } = app.options;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!apiKey) {\r\n        if (measurementId) {\r\n            return {\r\n                measurementId,\r\n                appId\r\n            };\r\n        }\r\n        throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n    }\r\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\r\n        backoffCount: 0,\r\n        throttleEndTimeMillis: Date.now()\r\n    };\r\n    const signal = new AnalyticsAbortSignal();\r\n    setTimeout(async () => {\r\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n        signal.abort();\r\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\r\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\r\n}\r\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\r\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\r\n) {\r\n    var _a;\r\n    const { appId, measurementId } = appFields;\r\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n    // Ensures the throttle end time is honored if the last attempt timed out.\r\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n    try {\r\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\r\n    }\r\n    catch (e) {\r\n        if (measurementId) {\r\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\r\n                ` Falling back to the measurement ID ${measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);\r\n            return { appId, measurementId };\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        const response = await fetchDynamicConfig(appFields);\r\n        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n        retryData.deleteThrottleMetadata(appId);\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        const error = e;\r\n        if (!isRetriableError(error)) {\r\n            retryData.deleteThrottleMetadata(appId);\r\n            if (measurementId) {\r\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\r\n                    ` Falling back to the measurement ID ${measurementId}` +\r\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\r\n                return { appId, measurementId };\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503\r\n            ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\r\n            : calculateBackoffMillis(backoffCount, retryData.intervalMillis);\r\n        // Increments backoff state.\r\n        const throttleMetadata = {\r\n            throttleEndTimeMillis: Date.now() + backoffMillis,\r\n            backoffCount: backoffCount + 1\r\n        };\r\n        // Persists state.\r\n        retryData.setThrottleMetadata(appId, throttleMetadata);\r\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\r\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\r\n    }\r\n}\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise((resolve, reject) => {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        const timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(() => {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof FirebaseError) || !e.customData) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    const httpStatus = Number(e.customData['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nclass AnalyticsAbortSignal {\r\n    constructor() {\r\n        this.listeners = [];\r\n    }\r\n    addEventListener(listener) {\r\n        this.listeners.push(listener);\r\n    }\r\n    abort() {\r\n        this.listeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\r\nlet defaultEventParametersForInit;\r\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\r\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, eventParams);\r\n        return;\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, params);\r\n    }\r\n}\r\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\r\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'screen_name': screenName });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'screen_name': screenName\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\r\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'user_id': id });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_id': id\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\r\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\r\n    if (options && options.global) {\r\n        const flatProperties = {};\r\n        for (const key of Object.keys(properties)) {\r\n            // use dot notation for merge behavior in gtag.js\r\n            flatProperties[`user_properties.${key}`] = properties[key];\r\n        }\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, flatProperties);\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_properties': properties\r\n        });\r\n    }\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n */\r\nasync function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {\r\n    const measurementId = await initializationPromise;\r\n    return new Promise((resolve, reject) => {\r\n        gtagFunction(\"get\" /* GtagCommand.GET */, measurementId, 'client_id', (clientId) => {\r\n            if (!clientId) {\r\n                reject(ERROR_FACTORY.create(\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */));\r\n            }\r\n            resolve(clientId);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\r\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\r\n    const measurementId = await initializationPromise;\r\n    window[`ga-disable-${measurementId}`] = !enabled;\r\n}\r\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\r\nlet defaultConsentSettingsForInit;\r\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction _setConsentDefaultForInit(consentSettings) {\r\n    defaultConsentSettingsForInit = consentSettings;\r\n}\r\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\r\nfunction _setDefaultEventParametersForInit(customParams) {\r\n    defaultEventParametersForInit = customParams;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function validateIndexedDB() {\r\n    if (!isIndexedDBAvailable()) {\r\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n            errorInfo: 'IndexedDB is not available in this environment.'\r\n        }).message);\r\n        return false;\r\n    }\r\n    else {\r\n        try {\r\n            await validateIndexedDBOpenable();\r\n        }\r\n        catch (e) {\r\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n                errorInfo: e === null || e === void 0 ? void 0 : e.toString()\r\n            }).message);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\r\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\r\n    var _a;\r\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\r\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\r\n    dynamicConfigPromise\r\n        .then(config => {\r\n        measurementIdToAppId[config.measurementId] = config.appId;\r\n        if (app.options.measurementId &&\r\n            config.measurementId !== app.options.measurementId) {\r\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\r\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\r\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\r\n                ` update the` +\r\n                ` measurement ID field in the local config or remove it from the local config.`);\r\n        }\r\n    })\r\n        .catch(e => logger.error(e));\r\n    // Add to list to track state of all dynamic config promises.\r\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\r\n    const fidPromise = validateIndexedDB().then(envIsValid => {\r\n        if (envIsValid) {\r\n            return installations.getId();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    });\r\n    const [dynamicConfig, fid] = await Promise.all([\r\n        dynamicConfigPromise,\r\n        fidPromise\r\n    ]);\r\n    // Detect if user has already put the gtag <script> tag on this page with the passed in\r\n    // data layer name.\r\n    if (!findGtagScriptOnPage(dataLayerName)) {\r\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\r\n    }\r\n    // Detects if there are consent settings that need to be configured.\r\n    if (defaultConsentSettingsForInit) {\r\n        gtagCore(\"consent\" /* GtagCommand.CONSENT */, 'default', defaultConsentSettingsForInit);\r\n        _setConsentDefaultForInit(undefined);\r\n    }\r\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\r\n    // but since it is idempotent, we can call it multiple times.\r\n    // We keep it together with other initialization logic for better code structure.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    gtagCore('js', new Date());\r\n    // User config added first. We don't want users to accidentally overwrite\r\n    // base Firebase config properties.\r\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\r\n    // guard against developers accidentally setting properties with prefix `firebase_`\r\n    configProperties[ORIGIN_KEY] = 'firebase';\r\n    configProperties.update = true;\r\n    if (fid != null) {\r\n        configProperties[GA_FID_KEY] = fid;\r\n    }\r\n    // It should be the first config command called on this GA-ID\r\n    // Initialize this GA-ID and set FID on it using the gtag config API.\r\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\r\n    // `configProperties`.\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, dynamicConfig.measurementId, configProperties);\r\n    // Detects if there is data that will be set on every event logged from the SDK.\r\n    if (defaultEventParametersForInit) {\r\n        gtagCore(\"set\" /* GtagCommand.SET */, defaultEventParametersForInit);\r\n        _setDefaultEventParametersForInit(undefined);\r\n    }\r\n    return dynamicConfig.measurementId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Analytics Service class.\r\n */\r\nclass AnalyticsService {\r\n    constructor(app) {\r\n        this.app = app;\r\n    }\r\n    _delete() {\r\n        delete initializationPromisesMap[this.app.options.appId];\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\r\nlet initializationPromisesMap = {};\r\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\r\nlet dynamicConfigPromisesList = [];\r\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\r\nconst measurementIdToAppId = {};\r\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\r\nlet dataLayerName = 'dataLayer';\r\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\r\nlet gtagName = 'gtag';\r\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\r\nlet gtagCoreFunction;\r\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\r\nlet wrappedGtagFunction;\r\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\r\nlet globalInitDone = false;\r\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\r\nfunction settings(options) {\r\n    if (globalInitDone) {\r\n        throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n    }\r\n    if (options.dataLayerName) {\r\n        dataLayerName = options.dataLayerName;\r\n    }\r\n    if (options.gtagName) {\r\n        gtagName = options.gtagName;\r\n    }\r\n}\r\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\r\nfunction warnOnBrowserContextMismatch() {\r\n    const mismatchedEnvMessages = [];\r\n    if (isBrowserExtension()) {\r\n        mismatchedEnvMessages.push('This is a browser extension environment.');\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        mismatchedEnvMessages.push('Cookies are not available.');\r\n    }\r\n    if (mismatchedEnvMessages.length > 0) {\r\n        const details = mismatchedEnvMessages\r\n            .map((message, index) => `(${index + 1}) ${message}`)\r\n            .join(' ');\r\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */, {\r\n            errorInfo: details\r\n        });\r\n        logger.warn(err.message);\r\n    }\r\n}\r\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\r\nfunction factory(app, installations, options) {\r\n    warnOnBrowserContextMismatch();\r\n    const appId = app.options.appId;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!app.options.apiKey) {\r\n        if (app.options.measurementId) {\r\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\r\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n        }\r\n    }\r\n    if (initializationPromisesMap[appId] != null) {\r\n        throw ERROR_FACTORY.create(\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */, {\r\n            id: appId\r\n        });\r\n    }\r\n    if (!globalInitDone) {\r\n        // Steps here should only be done once per page: creation or wrapping\r\n        // of dataLayer and global gtag function.\r\n        getOrCreateDataLayer(dataLayerName);\r\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\r\n        wrappedGtagFunction = wrappedGtag;\r\n        gtagCoreFunction = gtagCore;\r\n        globalInitDone = true;\r\n    }\r\n    // Async but non-blocking.\r\n    // This map reflects the completion state of all promises for each appId.\r\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\r\n    const analyticsInstance = new AnalyticsService(app);\r\n    return analyticsInstance;\r\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction getAnalytics(app = getApp()) {\r\n    app = getModularInstance(app);\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        return analyticsProvider.getImmediate();\r\n    }\r\n    return initializeAnalytics(app);\r\n}\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction initializeAnalytics(app, options = {}) {\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        const existingInstance = analyticsProvider.getImmediate();\r\n        if (deepEqual(options, analyticsProvider.getOptions())) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const analyticsInstance = analyticsProvider.initialize({ options });\r\n    return analyticsInstance;\r\n}\r\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\r\nasync function isSupported() {\r\n    if (isBrowserExtension()) {\r\n        return false;\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        return false;\r\n    }\r\n    if (!isIndexedDBAvailable()) {\r\n        return false;\r\n    }\r\n    try {\r\n        const isDBOpenable = await validateIndexedDBOpenable();\r\n        return isDBOpenable;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\r\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nasync function getGoogleAnalyticsClientId(analyticsInstance) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\r\n}\r\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\r\nfunction setUserId(analyticsInstance, id, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\r\nfunction setUserProperties(analyticsInstance, properties, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\r\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\r\nfunction setDefaultEventParameters(customParams) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"set\" /* GtagCommand.SET */, customParams);\r\n    }\r\n    else {\r\n        _setDefaultEventParametersForInit(customParams);\r\n    }\r\n}\r\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\r\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction setConsent(consentSettings) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"consent\" /* GtagCommand.CONSENT */, 'update', consentSettings);\r\n    }\r\n    else {\r\n        _setConsentDefaultForInit(consentSettings);\r\n    }\r\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.8\";\n\n/**\r\n * The Firebase Analytics Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction registerAnalytics() {\r\n    _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const installations = container\r\n            .getProvider('installations-internal')\r\n            .getImmediate();\r\n        return factory(app, installations, analyticsOptions);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    registerVersion(name, version);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name, version, 'esm2017');\r\n    function internalFactory(container) {\r\n        try {\r\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\r\n            return {\r\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */, {\r\n                reason: e\r\n            });\r\n        }\r\n    }\r\n}\r\nregisterAnalytics();\n\nexport { getAnalytics, getGoogleAnalyticsClientId, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings };\n//# sourceMappingURL=index.esm2017.js.map\n"],"names":["name","version","PENDING_TIMEOUT_MS","PACKAGE_VERSION","INTERNAL_AUTH_VERSION","TOKEN_EXPIRATION_BUFFER","ERROR_FACTORY","ErrorFactory","isServerError","error","FirebaseError","code","includes","getInstallationsEndpoint","projectId","extractAuthTokenInfoFromResponse","response","token","requestStatus","expiresIn","responseExpiresIn","Number","replace","creationTime","Date","now","async","getErrorFromResponse","requestName","errorData","json","create","serverCode","serverMessage","message","serverStatus","status","getHeaders","apiKey","Headers","Accept","getHeadersWithAuth","appConfig","refreshToken","headers","append","getAuthorizationHeader","retryIfServerError","fn","result","sleep","ms","Promise","resolve","setTimeout","VALID_FID_PATTERN","generateFid","fidByteArray","Uint8Array","self","crypto","msCrypto","getRandomValues","fid","b64String","array","btoa","String","fromCharCode","substr","encode","test","_a","getKey","appName","appId","fidChangeCallbacks","Map","fidChanged","key","callFidChangeCallbacks","channel","broadcastChannel","BroadcastChannel","onmessage","e","data","getBroadcastChannel","postMessage","size","close","broadcastFidChange","callbacks","get","callback","OBJECT_STORE_NAME","dbPromise","getDbPromise","openDB","upgrade","db","oldVersion","createObjectStore","set","value","tx","transaction","objectStore","oldValue","put","done","remove","delete","update","updateFn","store","newValue","getInstallationEntry","installations","registrationPromise","installationEntry","oldEntry","entry","registrationStatus","clearTimedOutRequest","updateOrCreateInstallationEntry","entryWithPromise","navigator","onLine","reject","inProgressEntry","registrationTime","registeredInstallationEntry","heartbeatServiceProvider","endpoint","heartbeatService","getImmediate","optional","heartbeatsHeader","getHeartbeatsHeader","body","authVersion","sdkVersion","request","method","JSON","stringify","fetch","ok","responseValue","authToken","createInstallationRequest","customData","registerInstallation","waitUntilFidRegistration","triggerRegistrationIfNecessary","updateInstallationRequest","generateAuthTokenRequest","getGenerateAuthTokenEndpoint","installation","refreshAuthToken","forceRefresh","tokenPromise","isEntryRegistered","oldAuthToken","isAuthTokenExpired","isAuthTokenValid","updateAuthTokenRequest","waitUntilAuthTokenRequest","inProgressAuthToken","requestTime","Object","assign","makeAuthTokenRequestInProgressEntry","updatedInstallationEntry","fetchAuthTokenFromServer","getToken","installationsImpl","completeInstallationRegistration","getMissingValueError","valueName","INSTALLATIONS_NAME","internalFactory","container","app","getProvider","_getProvider","getId","catch","console","_registerComponent","Component","options","configKeys","keyName","extractAppConfig","_delete","registerVersion","ANALYTICS_TYPE","GTAG_URL","logger","Logger","createGtagTrustedTypesScriptURL","url","startsWith","err","gtagURL","warn","promiseAllSettled","promises","all","map","promise","insertScriptTag","dataLayerName","measurementId","trustedTypesPolicy","policyName","policyOptions","window","trustedTypes","createPolicy","createTrustedTypesPolicy","createScriptURL","script","document","createElement","gtagScriptURL","src","head","appendChild","wrapGtag","gtagCore","initializationPromisesMap","dynamicConfigPromisesList","measurementIdToAppId","command","args","gtagParams","initializationPromisesToWaitFor","gaSendToList","Array","isArray","dynamicConfigResults","sendToId","foundConfig","find","config","initializationPromise","push","length","values","gtagOnEvent","correspondingAppId","gtagOnConfig","consentAction","fieldName","customParams","defaultRetryData","constructor","throttleMetadata","intervalMillis","this","getThrottleMetadata","setThrottleMetadata","metadata","deleteThrottleMetadata","fetchDynamicConfigWithRetry","retryData","timeoutMillis","backoffCount","throttleEndTimeMillis","signal","AnalyticsAbortSignal","abort","attemptFetchDynamicConfigWithRetry","appFields","backoffMillis","Math","max","timeout","addEventListener","clearTimeout","setAbortableTimeout","appUrl","errorMessage","jsonResponse","_ignored","httpStatus","responseMessage","fetchDynamicConfig","isRetriableError","calculateBackoffMillis","debug","listeners","listener","forEach","defaultEventParametersForInit","defaultConsentSettingsForInit","_setConsentDefaultForInit","consentSettings","_setDefaultEventParametersForInit","_initializeAnalytics","dynamicConfigPromise","then","fidPromise","isIndexedDBAvailable","errorInfo","validateIndexedDBOpenable","toString","validateIndexedDB","envIsValid","dynamicConfig","scriptTags","getElementsByTagName","tag","findGtagScriptOnPage","configProperties","AnalyticsService","gtagCoreFunction","wrappedGtagFunction","gtagName","globalInitDone","settings","factory","mismatchedEnvMessages","isBrowserExtension","areCookiesEnabled","details","index","join","warnOnBrowserContextMismatch","id","dataLayer","getOrCreateDataLayer","wrappedGtag","gtagFunctionName","_args","arguments","wrapOrCreateGtag","getAnalytics","getApp","getModularInstance","analyticsProvider","isInitialized","initializeAnalytics","existingInstance","deepEqual","getOptions","initialize","isSupported","setCurrentScreen","analyticsInstance","screenName","gtagFunction","global","screen_name","setCurrentScreen$1","getGoogleAnalyticsClientId","clientId","internalGetGoogleAnalyticsClientId","setUserId","user_id","setUserId$1","setUserProperties","properties","flatProperties","keys","user_properties","setUserProperties$1","setAnalyticsCollectionEnabled","enabled","setAnalyticsCollectionEnabled$1","setDefaultEventParameters","logEvent","eventName","eventParams","send_to","logEvent$1","setConsent","analyticsOptions","analytics","reason"],"mappings":"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","x_google_ignoreList":[0,1]}